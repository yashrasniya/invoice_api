import logging

import django
import yaml
import copy

from django.conf import settings

from submit import Submit
from PIL import Image
logger = logging.getLogger(__name__)

class Point:

    def __init__(self,title,x=None,y=None,label=None,value=None,**kwargs):
        self.title=title
        self.x=x
        self.y=y
        self.value=value
        self.label=label
        self.raw=kwargs
        self.next_line=kwargs.get('next_line',None)
        self.font_size=kwargs.get('font_size',None)
        self.font=kwargs.get('font',None)
        self.limit=kwargs.get('limit',None)
        self.no_lines=kwargs.get('no_lines',1)
        self.suffix=kwargs.get('suffix',None)
        self.prefix=kwargs.get('prefix',None)
        self.autoGenerated=kwargs.get('autoGenerated',False)

    def add_suffix(self):
        if self.suffix is not None:
            self.value=str(self.value)+self.suffix
    def type(self):
        return "Point"
    def go_down(self,d):
        self.y -= d

    def add_prefix(self):
        if self.prefix:
            self.value = self.prefix  + str(self.value)

    def type(self):
        return "Point"

    def __str__(self):
        return self.title
class Polygon:
    def __init__(self, title, points=None, **kwargs):
        """
        :param title: Name/identifier of the polygon
        :param points: List of (x, y) tuples [(x1, y1), (x2, y2), ...]
        :param kwargs: Extra attributes like stroke, fill, line_width, etc.
        """
        self.title = title
        self.points = points if points is not None else []
        self.raw = kwargs
        self.label =kwargs.get("label",'')

        # Style/extra attributes
        self.stroke = kwargs.get("stroke_color", "black")   # outline color
        self.fill = kwargs.get("fill", None)         # fill color (None = transparent)
        self.src = kwargs.get("src", None)         # fill color (None = transparent)
        self.rectangles_type = kwargs.get("rectangles_type", None)         # fill color (None = transparent)
        self.line_width = kwargs.get("line_width", 1)
        self.closed = kwargs.get("closed", True)     # auto-close polygon

    def add_point(self, x, y):
        """Add a new point (x,y) to polygon"""
        self.points.append((x, y))

    def type(self):
        return "Polygon"

    def get_bounds(self):
        """Return bounding box (min_x, min_y, max_x, max_y)"""
        if not self.points:
            return None
        xs, ys = zip(*self.points)
        return min(xs), min(ys), max(xs), max(ys)

    def go_down(self,d):
        points = []
        for i,y in enumerate(self.points):
            y = self.points[i][1] - d
            x = self.points[i][0]
            points.append((x,y))
        self.points = points
    def __str__(self):
        return f"Polygon({self.title}, points={len(self.points)})"
import random

class Line:
    def __init__(self, x, y, x2, y2, height=None, **kwargs):
        """
        :param x, y: Start point
        :param x2, y2: End point
        :param height: (optional) page height, for coordinate transform (y -> height - y)
        :param kwargs: Extra attributes like stroke_color, line_width, label, etc.
        """
        # Handle coordinate transformation if height is provided
        if height:
            y1 = height - y
            y2 = height - y2

        self.x = x
        self.x1 = x
        self.y = y
        self.y1 = y
        self.x2 = x2
        self.y2 = y2

        # Style/extra attributes
        self.stroke = kwargs.get("stroke_color", "black")
        self.line_width = kwargs.get("line_width", 1)
        self.label = kwargs.get("label", str(random.randint(1000, 9999)))  # default random label
        self.raw = kwargs

    def type(self):
        return "Line"

    def go_down(self, d):
        self.y1 -= d
        self.y2 -= d

    def length(self):
        """Return length of line (Euclidean distance)"""
        return ((self.x2 - self.x1) ** 2 + (self.y2 - self.y1) ** 2) ** 0.5

    def get_bounds(self):
        """Return bounding box (min_x, min_y, max_x, max_y)"""
        return min(self.x1, self.x2), min(self.y1, self.y2), max(self.x1, self.x2), max(self.y1, self.y2)

    def to_dict(self):
        """Export as a dict (useful for JSON/YAML export)"""
        return {
            "type": "line",
            "x1": self.x1,
            "y1": self.y1,
            "x2": self.x2,
            "y2": self.y2,
            "stroke": self.stroke,
            "line_width": self.line_width,
            "label": self.label
        }

    def __str__(self):
        return f"Line(({self.x1},{self.y1}) -> ({self.x2},{self.y2}), label={self.label})"


def create_rectangle(title, x, y, width, height=0, **kwargs):
    """
    Create a rectangle polygon from start (x, y) with given width & height.

    :param title: Name/identifier for rectangle
    :param x: X start
    :param y: Y start
    :param width: Rectangle width
    :param height: Rectangle height
    :param kwargs: Extra attributes (stroke, fill, line_width, etc.)
    :return: Polygon instance
    """
    points = [
        (x, y),                    # bottom-left
        (x + width, y),            # bottom-right
        (x + width, y + height),   # top-right
        (x, y + height)            # top-left
    ]
    return Polygon(title, points=points, **kwargs)
def get_yaml_data(name):
    with open(str(name), "r") as file:
        yaml_raw_data = yaml.safe_load(file)
    return yaml_raw_data

def serialize_data(data):
    serialized_data=[]
    for item in data:
        for key, coordinates in item.items():
            if coordinates.get("type",'') =="rectangles":
                obj = create_rectangle(key,**coordinates)
            elif coordinates.get("type",'') =="line":
                obj = Line(**coordinates)
            else:
                obj = Point(key, **coordinates)
            serialized_data.append(obj)
    return serialized_data

def num2words(num):
    under_20 = ['Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven',
                'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']
    tens = ['Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']
    above_100 = {100: 'Hundred', 1000: 'Thousand', 100000: 'Lack', 10000000: 'Crore'}

    if num < 20:
        return under_20[int(num)]

    if num < 100:
        return tens[(int)(num / 10) - 2] + ('' if num % 10 == 0 else ' ' + under_20[int(num) % 10])

    # find the appropriate pivot - 'Million' in 3,603,550, or 'Thousand' in 603,550
    pivot = max([key for key in above_100.keys() if key <= num])

    return num2words((int)(num / pivot)) + ' ' + above_100[pivot] + ('' if num % pivot == 0 else ' ' + num2words(num % pivot))

def check_value_name(key,yaml_header_list, values,index=0):

    for d in yaml_header_list:
        logger.debug(f"{d=} {values=} {key=}")
        if key.lower() ==str(d):
            d.value= values[key]
            return True
        if key.lower() ==d.label:
            d.value = values[key]
            return True
        if "," in d.label:
            labels=d.label.split(",")
            if key.lower() == labels[0] and values.get(key,None):
                for i in values.get(key):
                    check_value_name(i,yaml_header_list,values[key],index=1)
                return True
            labels=labels[index:]
            label=None
            new_value=values
            for label in labels:
                if new_value:
                    new_value=new_value.get(label,None)
            if label==key:
                d.value = new_value
                return True
    return None


class YamalReader:

    def __init__(self,name,auto_scale=False):
        self.name=name
        self.headers=[]
        self.footers=[]
        self.bill_stretcher=[]
        self.product_stretcher=[]
        self.my_company_details=[]
        self.products=[]
        self.start=None
        self.product_config=None
        self.yaml_raw_data=None
        self.auto_scale=auto_scale
        self.serialize_data()

    def serialize_data(self):
        yaml_raw_data=get_yaml_data(self.name)
        self.headers=serialize_data(yaml_raw_data["Bill"]["harder"])
        self.bill_stretcher=serialize_data(yaml_raw_data["Bill"].get("bill_stretcher",[]))
        self.product_stretcher=serialize_data(yaml_raw_data["Bill"].get("product_stretcher",[]))
        self.my_company_details=serialize_data(yaml_raw_data["Bill"].get("my_company_details",[]))
        self.footers=serialize_data(yaml_raw_data["Bill"]["footer"])
        self.products=serialize_data(yaml_raw_data["Bill"]["product"]["product_list"])
        if yaml_raw_data["Bill"]["product"].get("start"):
            self.start=yaml_raw_data["Bill"]["product"].get("start")
            self.product_config=yaml_raw_data["Bill"]["product"].get("product_config",{})
        self.yaml_raw_data = yaml_raw_data


class FillValue:
    def __init__(self,data,yaml_obj):
        self.data=data
        self.yaml_obj=yaml_obj
        self.headers=self.yaml_obj.headers.copy()
        self.footers=self.yaml_obj.footers.copy()
        self.bill_stretcher=self.yaml_obj.bill_stretcher.copy()
        self.product_stretcher=self.yaml_obj.product_stretcher.copy()
        self.my_company_details=self.yaml_obj.my_company_details.copy()
        self.products=[]
        self.raw_footer_data={}
        self.set_header()
        self.set_products()
        self.set_footer()


    def set_header(self):
        for key in self.data.keys():
            check_value_name(
                key,
             yaml_header_list=self.headers,
             values=self.data)

    def set_products(self):
        start=self.yaml_obj.start
        total_amount=0
        gst_list=[]
        for index, product in enumerate(self.data.get("products")):
            callable_values=1
            other_callable_values=[]
            products_list=copy.deepcopy(self.yaml_obj.products)
            for product_properties in product.get("product_properties"):
                is_show=product_properties.get("new_product_in_frontend").get("is_show",False)
                input_title=product_properties.get("new_product_in_frontend").get("input_title",'')
                is_calculable=product_properties.get("new_product_in_frontend").get("is_calculable",False)
                formula=product_properties.get("new_product_in_frontend").get("formula",'')
                value=product_properties.get("value")
                if input_title=="GST":
                    gst_list.append(int(value))
                for i in products_list:
                    all_label = [ k.lower() for k in i.label.split(',') ]
                    all_label.append(str(i).lower())
                    i.font_size = i.font_size if i.font_size else self.yaml_obj.product_config.get("font_size")
                    i.font = i.font if i.font else self.yaml_obj.product_config.get("font")

                    if "s.no" in all_label:
                        i.value=index+1
                        i.y=start
                        self.products.append(i)
                    if input_title.lower() in all_label:
                        if is_show:
                            i.value=value
                            i.y=start
                            self.products.append(i)
                if is_calculable and input_title!="GST":
                    if formula:
                        other_callable_values.append({"formula":formula,value:value})
                    else:
                        callable_values*=float(value if value else 1)
            for i in self.yaml_obj.products:
                i = copy.copy(i)
                i.font_size = i.font_size if i.font_size else self.yaml_obj.product_config.get("font_size")
                i.font = i.font if i.font else self.yaml_obj.product_config.get("font")
                if i.label=="amount":
                    i.value = round(callable_values,2)
                    i.y = start
                    self.products.append(i)
                    total_amount+=callable_values
                elif i.autoGenerated:
                    if i.label in ["Amount_after_GST","C_GST","S_GST"]:
                        self.products.append(i)
                        i.y = start
                    if i.label=="Amount_after_GST":
                        i.value=round(callable_values+(callable_values*(gst_list[-1]/100)))
                    elif i.label=="C_GST":
                        i.value = round( (callable_values * (gst_list[-1] / 100))/2,2)
                    elif i.label=="S_GST":
                        i.value = round( (callable_values * (gst_list[-1] / 100))/2,2)


            start-=self.yaml_obj.product_config.get("product_gap",15)
        self.raw_footer_data["gst"]=round(sum(gst_list)/len(gst_list),2) if gst_list else 0
        self.raw_footer_data["gst_amount"]=round(total_amount*(self.raw_footer_data["gst"]/100),2)
        self.raw_footer_data["total_amount_with_out_gst"]=round(total_amount,2)
        self.raw_footer_data["total_amount_with_gst"]=round(total_amount+self.raw_footer_data["gst_amount"],2)
        # logger.error(f"{round(self.raw_footer_data["total_amount_with_gst"],2)=}")
        self.raw_footer_data["total_amount_in_text"]=num2words(round(self.raw_footer_data["total_amount_with_gst"],2))
        self.raw_footer_data["center_gst"]=round(self.raw_footer_data["gst"]/2,2)
        self.raw_footer_data["state_gst"]=round(self.raw_footer_data["gst"]/2,2)
        self.raw_footer_data["center_gst_amount"]=round(self.raw_footer_data["gst_amount"]/2,2)
        self.raw_footer_data["state_gst_amount"]=round(self.raw_footer_data["gst_amount"]/2,2)

    def set_footer(self):
        difference= 0
        if self.products and self.products[-1].y < self.footers[0].y and self.yaml_obj.auto_scale:
            difference = self.footers[0].y -  self.products[-1].y + 5
            for k in self.product_stretcher:
                if k.type() == "Line":
                    k.y2 -= difference
                elif k.type() =="Polygon":
                    k.points = [
                        k.points[0],
                        k.points[1],
                        (k.points[2][0],k.points[2][1] - difference),
                        (k.points[3][0],k.points[3][1] - difference),
                                ]

            # if self.footers[-1].y - difference < 0:
            #     print(f"next page {difference=}")
        for i in self.footers:
            if difference:
                i.go_down(difference)
            if self.raw_footer_data.get(i.label):
                i.value=self.raw_footer_data.get(i.label)

    def collect_all_data(self):
        data=[]
        data.extend(self.bill_stretcher)
        data.extend(self.product_stretcher)
        data.extend(self.my_company_details)
        data.extend(self.headers)
        data.extend(self.products)
        data.extend(self.footers)
        return copy.copy(data)

    def set_my_company_data(self,request):
        if request.user.user_company and request.user.user_company.is_varified:
            obj = request.user.user_company
            for i in self.my_company_details + self.footers:
                if hasattr(i, 'rectangles_type') and obj.company_logo and i.rectangles_type == 'image':
                    points = i.points
                    xs = [p[0] for p in points]
                    ys = [p[1] for p in points]

                    x = min(xs)
                    y = min(ys)
                    width = max(xs) - x
                    height = obj.logo_scaled_height(width)
                    points = [
                        (x, y),  # bottom-left
                        (x + width, y),  # bottom-right
                        (x + width, y + height),  # top-right (adjusted height)
                        (x, y + height)  # top-left (adjusted height)
                    ]
                    i.points = points
                    i.src = getattr(obj, str(i.label).lower(), '')
                    i.src = request.build_absolute_uri(settings.MEDIA_URL + str(i.src))
                if i.type() == 'Point' and hasattr(obj,str(str(i.label).lower())):
                    i.value = getattr(obj,str(i.label).lower(),'')








